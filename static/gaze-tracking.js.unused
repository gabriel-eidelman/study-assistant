// Simplified gaze-tracking.js for Study Assistant
// This version avoids conflicts with face-api.js

// Global variables for gaze tracking
let gazeTracking = {
  isCalibrated: false,
  isTracking: false,
  calibrationPoints: 0,
  requiredCalibrationPoints: 5,
  gazeData: [],
  gazeHistory: [], // Last 30 gaze points
  lookingAtScreen: true,
  lookingAtContent: true,
  blinkDetected: false,
  lastBlinkTime: Date.now(),
  blinkCount: 0,
  blinkHistory: [], // For blink rate calculation
  attentionScore: 1.0,
  inScreenPercentage: 100,
  inContentPercentage: 100,
  contentArea: { // Will be set based on actual content area
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  },
  gazeDataValid: false,
  predictionError: 0
};

/**
 * Initialize WebGazer and prepare for calibration
 * Should be called when the user starts the webcam
 */
async function initializeGazeTracking() {
  try {
    // Check if WebGazer is available
    if (typeof webgazer === 'undefined') {
      console.error("WebGazer library not loaded");
      if (typeof showError === 'function') {
        showError("Gaze tracking library not available. Falling back to basic tracking.");
      }
      return false;
    }
    
    // Set up WebGazer with custom options
    webgazer.params.showVideo = true; // Show video during calibration
    webgazer.params.showFaceOverlay = true; // Show face tracking
    webgazer.params.showFaceFeedbackBox = true; // Show face tracking box
    webgazer.params.showGazeDot = true; // Show gaze dot during calibration
    
    // Reduce storage to avoid memory issues
    webgazer.params.storingPoints = false;
    
    // Start WebGazer
    await webgazer.begin();
    
    // Set up the gaze listener
    webgazer.setGazeListener(function(data, elapsedTime) {
      if (data == null) {
        // No gaze detected - possible blink or looking away
        handleGazeDataMissing();
      } else {
        // Process valid gaze data
        processGazeData(data);
      }
    });
    
    // Define content areas (where study materials appear)
    updateContentArea();
    
    // Add window resize handler to update content area
    window.addEventListener('resize', updateContentArea);
    
    gazeTracking.isTracking = true;
    return true;
  } catch (error) {
    console.error("Error initializing WebGazer:", error);
    if (typeof showError === 'function') {
      showError(`Gaze tracking initialization failed: ${error.message}. Falling back to basic tracking.`);
    }
    return false;
  }
}

/**
 * Update the definition of content area (where study materials appear)
 */
function updateContentArea() {
  // Get the main content element where study material is shown
  const videoContainer = document.querySelector('.video-container');
  
  if (videoContainer) {
    const rect = videoContainer.getBoundingClientRect();
    
    // Define content area
    gazeTracking.contentArea = {
      left: rect.left,
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      width: rect.width,
      height: rect.height
    };
  } else {
    // Default to central 70% of screen if element not found
    gazeTracking.contentArea = {
      left: window.innerWidth * 0.15,
      top: window.innerHeight * 0.15,
      right: window.innerWidth * 0.85,
      bottom: window.innerHeight * 0.85,
      width: window.innerWidth * 0.7,
      height: window.innerHeight * 0.7
    };
  }
}

/**
 * Process gaze data from WebGazer
 */
function processGazeData(data) {
  // Reset blink detection flag
  gazeTracking.blinkDetected = false;
  
  // Get x, y coordinates
  const x = data.x;
  const y = data.y;
  
  // Check data validity
  if (isNaN(x) || isNaN(y) || x < 0 || y < 0 || x > window.innerWidth || y > window.innerHeight) {
    handleGazeDataMissing();
    return;
  }
  
  // Store gaze data
  gazeTracking.gazeData = { x, y, timestamp: Date.now() };
  gazeTracking.gazeDataValid = true;
  
  // Add to history (keep last 30 points)
  gazeTracking.gazeHistory.push({ x, y, timestamp: Date.now() });
  if (gazeTracking.gazeHistory.length > 30) {
    gazeTracking.gazeHistory.shift();
  }
  
  // Check if looking at screen
  const inScreen = 
    x >= 0 && x <= window.innerWidth && 
    y >= 0 && y <= window.innerHeight;
  
  // Check if looking at content area
  const inContent = 
    x >= gazeTracking.contentArea.left && 
    x <= gazeTracking.contentArea.right && 
    y >= gazeTracking.contentArea.top && 
    y <= gazeTracking.contentArea.bottom;
  
  // Update status
  gazeTracking.lookingAtScreen = inScreen;
  gazeTracking.lookingAtContent = inContent;
  
  // Calculate attention percentages
  updateAttentionPercentages();
}

/**
 * Handle missing gaze data (potential blink or looking away)
 */
function handleGazeDataMissing() {
  const now = Date.now();
  
  // If we had valid data before and now it's missing, might be a blink
  if (gazeTracking.gazeDataValid) {
    const timeSinceLastValidData = now - gazeTracking.gazeData.timestamp;
    
    // If data missing for less than 400ms, likely a blink
    if (timeSinceLastValidData < 400) {
      detectBlink();
    } 
    // If data missing for longer, likely looking away
    else if (timeSinceLastValidData > 500) {
      gazeTracking.lookingAtScreen = false;
      gazeTracking.lookingAtContent = false;
    }
  }
  
  gazeTracking.gazeDataValid = false;
}

/**
 * Detect a blink event
 */
function detectBlink() {
  const now = Date.now();
  
  // Don't register blinks too close together (debounce)
  if (now - gazeTracking.lastBlinkTime < 500) {
    return;
  }
  
  // Record the blink
  gazeTracking.blinkDetected = true;
  gazeTracking.blinkCount++;
  gazeTracking.lastBlinkTime = now;
  
  // Store for blink rate calculation
  gazeTracking.blinkHistory.push(now);
  
  // Keep only last minute of blinks
  while (gazeTracking.blinkHistory.length > 0 && 
         gazeTracking.blinkHistory[0] < now - 60000) {
    gazeTracking.blinkHistory.shift();
  }
  
  // Update UI with blink count if elements exist
  if (typeof blinkCounterElement !== 'undefined' && blinkCounterElement) {
    blinkCounterElement.textContent = gazeTracking.blinkCount;
  }
  
  if (typeof lastBlinkTimeElement !== 'undefined' && lastBlinkTimeElement) {
    lastBlinkTimeElement.textContent = new Date(gazeTracking.lastBlinkTime).toLocaleTimeString();
  }
  
  // Update blink metric if element exists
  if (typeof blinkMetric !== 'undefined' && blinkMetric) {
    blinkMetric.textContent = 'Blinked ✓';
    setTimeout(() => {
      if (blinkMetric.textContent === 'Blinked ✓') {
        blinkMetric.textContent = 'Eyes open ✓';
      }
    }, 500);
  }
}

/**
 * Update percentage of time looking at screen/content
 */
function updateAttentionPercentages() {
  const now = Date.now();
  const historyDuration = 5000; // Last 5 seconds
  const cutoffTime = now - historyDuration;
  
  // Filter recent history
  const recentHistory = gazeTracking.gazeHistory.filter(item => item.timestamp > cutoffTime);
  
  if (recentHistory.length === 0) {
    return;
  }
  
  // Count points in screen and content
  const inScreenCount = recentHistory.filter(item => 
    item.x >= 0 && item.x <= window.innerWidth && 
    item.y >= 0 && item.y <= window.innerHeight
  ).length;
  
  const inContentCount = recentHistory.filter(item => 
    item.x >= gazeTracking.contentArea.left && 
    item.x <= gazeTracking.contentArea.right && 
    item.y >= gazeTracking.contentArea.top && 
    item.y <= gazeTracking.contentArea.bottom
  ).length;
  
  // Calculate percentages
  gazeTracking.inScreenPercentage = (inScreenCount / recentHistory.length) * 100;
  gazeTracking.inContentPercentage = (inContentCount / recentHistory.length) * 100;
  
  // Calculate overall attention score
  gazeTracking.attentionScore = gazeTracking.inContentPercentage / 100;
}

/**
 * Get the current blink rate from WebGazer
 */
function getGazeBlinkRate() {
  const now = Date.now();
  const oneMinuteAgo = now - 60000;
  
  // Count blinks in the last minute
  const blinkCount = gazeTracking.blinkHistory.filter(timestamp => timestamp > oneMinuteAgo).length;
  
  return blinkCount;
}

/**
 * Get the current attention level from gaze data
 */
function getGazeAttentionScore() {
  return gazeTracking.attentionScore;
}

/**
 * Simple stub for enhancedProcessFrame that uses the standard processFrame
 */
function enhancedProcessFrame() {
  // If processFrame is already defined, use it
  if (typeof processFrame === 'function') {
    processFrame();
  } else {
    // Simple fallback if no processFrame is available
    requestAnimationFrame(enhancedProcessFrame);
  }
}

// Make functions globally available
window.gazeTracking = gazeTracking;
window.initializeGazeTracking = initializeGazeTracking;
window.updateContentArea = updateContentArea;
window.processGazeData = processGazeData;
window.handleGazeDataMissing = handleGazeDataMissing;
window.detectBlink = detectBlink;
window.updateAttentionPercentages = updateAttentionPercentages;
window.getGazeBlinkRate = getGazeBlinkRate;
window.getGazeAttentionScore = getGazeAttentionScore;
window.enhancedProcessFrame = enhancedProcessFrame;
